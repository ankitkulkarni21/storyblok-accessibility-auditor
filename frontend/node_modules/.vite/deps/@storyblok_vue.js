import {
  createBlock,
  createSlots,
  createTextVNode,
  defineAsyncComponent,
  defineComponent,
  guardReactiveProps,
  h,
  inject,
  mergeProps,
  normalizeProps,
  onMounted,
  openBlock,
  ref,
  renderList,
  renderSlot,
  resolveDynamicComponent,
  watch,
  withCtx
} from "./chunk-4EPKHDIW.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@storyblok/vue/dist/storyblok-vue.mjs
var $e = Object.defineProperty;
var Re = (e, t, r) => t in e ? $e(e, t, { enumerable: true, configurable: true, writable: true, value: r }) : e[t] = r;
var b = (e, t, r) => Re(e, typeof t != "symbol" ? t + "" : t, r);
var k = (function(e) {
  return e.DOCUMENT = "doc", e.HEADING = "heading", e.PARAGRAPH = "paragraph", e.QUOTE = "blockquote", e.OL_LIST = "ordered_list", e.UL_LIST = "bullet_list", e.LIST_ITEM = "list_item", e.CODE_BLOCK = "code_block", e.HR = "horizontal_rule", e.BR = "hard_break", e.IMAGE = "image", e.EMOJI = "emoji", e.COMPONENT = "blok", e.TABLE = "table", e.TABLE_ROW = "tableRow", e.TABLE_CELL = "tableCell", e.TABLE_HEADER = "tableHeader", e;
})({});
var T = (function(e) {
  return e.BOLD = "bold", e.STRONG = "strong", e.STRIKE = "strike", e.UNDERLINE = "underline", e.ITALIC = "italic", e.CODE = "code", e.LINK = "link", e.ANCHOR = "anchor", e.STYLED = "styled", e.SUPERSCRIPT = "superscript", e.SUBSCRIPT = "subscript", e.TEXT_STYLE = "textStyle", e.HIGHLIGHT = "highlight", e;
})({});
var Ae = (function(e) {
  return e.TEXT = "text", e;
})({});
var O = (function(e) {
  return e.URL = "url", e.STORY = "story", e.ASSET = "asset", e.EMAIL = "email", e;
})({});
var Ee = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var Se = (e = {}) => Object.keys(e).map((t) => `${t}="${e[t]}"`).join(" ");
var Le = (e = {}) => Object.keys(e).map((t) => `${t}: ${e[t]}`).join("; ");
function Ie(e) {
  return e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
var L = (e) => Object.fromEntries(Object.entries(e).filter(([t, r]) => r !== void 0));
function Ce(e, t) {
  if (!t) return {
    src: e,
    attrs: {}
  };
  let r = 0, s = 0;
  const n = {}, o = [];
  function l(c, u, f, y, $) {
    typeof c != "number" || c <= u || c >= f ? console.warn(`[StoryblokRichText] - ${y.charAt(0).toUpperCase() + y.slice(1)} value must be a number between ${u} and ${f} (inclusive)`) : $.push(`${y}(${c})`);
  }
  if (typeof t == "object") {
    if (typeof t.width == "number" && t.width > 0 ? (n.width = t.width, r = t.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than 0"), t.height && typeof t.height == "number" && t.height > 0 ? (n.height = t.height, s = t.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than 0"), t.loading && ["lazy", "eager"].includes(t.loading) && (n.loading = t.loading), t.class && (n.class = t.class), t.filters) {
      const { filters: c } = t || {}, { blur: u, brightness: f, fill: y, format: $, grayscale: P, quality: _, rotate: E } = c || {};
      u && l(u, 0, 100, "blur", o), _ && l(_, 0, 100, "quality", o), f && l(f, 0, 100, "brightness", o), y && o.push(`fill(${y})`), P && o.push("grayscale()"), E && [
        0,
        90,
        180,
        270
      ].includes(t.filters.rotate || 0) && o.push(`rotate(${E})`), $ && [
        "webp",
        "png",
        "jpeg"
      ].includes($) && o.push(`format(${$})`);
    }
    t.srcset && (n.srcset = t.srcset.map((c) => {
      if (typeof c == "number") return `${e}/m/${c}x0/${o.length > 0 ? `filters:${o.join(":")}` : ""} ${c}w`;
      if (Array.isArray(c) && c.length === 2) {
        const [u, f] = c;
        return `${e}/m/${u}x${f}/${o.length > 0 ? `filters:${o.join(":")}` : ""} ${u}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), t.sizes && (n.sizes = t.sizes.join(", "));
  }
  let a = `${e}/m/`;
  return r > 0 && s > 0 && (a = `${a}${r}x${s}/`), o.length > 0 && (a = `${a}filters:${o.join(":")}`), {
    src: a,
    attrs: n
  };
}
function V(e, t = {}, r) {
  const s = Se(t), n = s ? `${e} ${s}` : e, o = Array.isArray(r) ? r.join("") : r || "";
  if (e) {
    if (Ee.includes(e)) return `<${n}>`;
  } else return o;
  return `<${n}>${o}</${e}>`;
}
function ee(e = {}) {
  const t = /* @__PURE__ */ new Map(), { renderFn: r = V, textFn: s = Ie, resolvers: n = {}, optimizeImages: o = false, keyedResolvers: l = false } = e, a = r !== V, c = (i = {}) => {
    const { textAlign: h2, class: d, id: p, style: m, ...v } = i, g = [];
    return m && g.push(m.endsWith(";") ? m : `${m};`), h2 && g.push(`text-align: ${h2};`), L({
      ...v,
      class: d,
      id: p,
      ...g.length > 0 ? { style: g.join(" ") } : {}
    });
  }, u = (i) => (h2, d) => {
    const p = c(h2.attrs);
    return d.render(i, p, h2.children || null);
  }, f = (i, h2) => {
    const { src: d, alt: p, title: m, srcset: v, sizes: g } = i.attrs || {};
    let R = d, w = {};
    if (o) {
      const { src: ue, attrs: he } = Ce(d, o);
      R = ue, w = he;
    }
    const S = {
      src: R,
      alt: p,
      title: m,
      srcset: v,
      sizes: g,
      ...w
    };
    return h2.render("img", L(S));
  }, y = (i, h2) => {
    const { level: d, ...p } = i.attrs || {}, m = c(p);
    return h2.render(`h${d}`, m, i.children);
  }, $ = (i, h2) => {
    var d, p, m, v;
    const g = h2.render("img", {
      src: (d = i.attrs) == null ? void 0 : d.fallbackImage,
      alt: (p = i.attrs) == null ? void 0 : p.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return h2.render("span", {
      "data-type": "emoji",
      "data-name": (m = i.attrs) == null ? void 0 : m.name,
      "data-emoji": (v = i.attrs) == null ? void 0 : v.emoji
    }, g);
  }, P = (i, h2) => h2.render("pre", i.attrs || {}, h2.render("code", {}, i.children || "")), _ = (i, h2 = false) => ({ text: d, attrs: p }, m) => {
    const { class: v, id: g, ...R } = p || {}, w = h2 ? {
      class: v,
      id: g,
      style: Le(R) || void 0
    } : p || {};
    return m.render(i, L(w), d);
  }, E = (i) => N(i), se = (i) => {
    const { marks: h2, ...d } = i;
    if ("text" in i) {
      if (h2) return h2.reduce((m, v) => E({
        ...v,
        text: m
      }), E({
        ...d,
        children: d.children
      }));
      const p = i.attrs || {};
      if (l) {
        const m = t.get("txt") || 0;
        t.set("txt", m + 1), p.key = `txt-${m}`;
      }
      return s(d.text, p);
    }
    return "";
  }, B = (i, h2) => {
    const { linktype: d, href: p, anchor: m, ...v } = i.attrs || {};
    let g = "";
    switch (d) {
      case O.ASSET:
      case O.URL:
        g = p;
        break;
      case O.EMAIL:
        g = `mailto:${p}`;
        break;
      case O.STORY:
        g = p, m && (g = `${g}#${m}`);
        break;
      default:
        g = p;
        break;
    }
    const R = { ...v };
    return g && (R.href = g), h2.render("a", R, i.text);
  }, ne = (i, h2) => {
    var d, p;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), h2.render("span", {
      blok: (d = i == null ? void 0 : i.attrs) == null ? void 0 : d.body[0],
      id: (p = i.attrs) == null ? void 0 : p.id,
      style: "display: none"
    });
  }, oe = (i, h2) => {
    const d = c(i.attrs), p = i.children || null;
    return h2.render("table", d, h2.render("tbody", {}, p));
  }, ie = (i, h2) => {
    const d = c(i.attrs);
    return h2.render("tr", d, i.children);
  }, ae = (i, h2) => {
    const { colspan: d, rowspan: p, colwidth: m, backgroundColor: v, textAlign: g, ...R } = i.attrs || {}, w = [];
    m && w.push(`width: ${m}px;`), v && w.push(`background-color: ${v};`), g && w.push(`text-align: ${g};`);
    const S = {
      ...R,
      ...d > 1 ? { colspan: d } : {},
      ...p > 1 ? { rowspan: p } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return h2.render("td", L(S), i.children);
  }, le = (i, h2) => {
    const { colspan: d, rowspan: p, colwidth: m, backgroundColor: v, textAlign: g, ...R } = i.attrs || {}, w = [];
    m && w.push(`width: ${m}px;`), v && w.push(`background-color: ${v};`), g && w.push(`text-align: ${g};`);
    const S = {
      ...R,
      ...d > 1 ? { colspan: d } : {},
      ...p > 1 ? { rowspan: p } : {},
      ...w.length > 0 ? { style: w.join(" ") } : {}
    };
    return h2.render("th", L(S), i.children);
  }, M = /* @__PURE__ */ new Map([
    [k.DOCUMENT, u("")],
    [k.HEADING, y],
    [k.PARAGRAPH, u("p")],
    [k.UL_LIST, u("ul")],
    [k.OL_LIST, u("ol")],
    [k.LIST_ITEM, u("li")],
    [k.IMAGE, f],
    [k.EMOJI, $],
    [k.CODE_BLOCK, P],
    [k.HR, u("hr")],
    [k.BR, u("br")],
    [k.QUOTE, u("blockquote")],
    [k.COMPONENT, ne],
    [Ae.TEXT, se],
    [T.LINK, B],
    [T.ANCHOR, B],
    [T.STYLED, _("span", true)],
    [T.BOLD, _("strong")],
    [T.TEXT_STYLE, _("span", true)],
    [T.ITALIC, _("em")],
    [T.UNDERLINE, _("u")],
    [T.STRIKE, _("s")],
    [T.CODE, _("code")],
    [T.SUPERSCRIPT, _("sup")],
    [T.SUBSCRIPT, _("sub")],
    [T.HIGHLIGHT, _("mark")],
    [k.TABLE, oe],
    [k.TABLE_ROW, ie],
    [k.TABLE_CELL, ae],
    [k.TABLE_HEADER, le]
  ]), F = new Map([...M, ...Object.entries(n).map(([i, h2]) => [i, h2])]), ce = () => ({
    render: (i, h2 = {}, d) => {
      if (l && i) {
        const p = t.get(i) || 0;
        t.set(i, p + 1), h2.key = `${i}-${p}`;
      }
      return r(i, h2, d);
    },
    originalResolvers: M,
    mergedResolvers: F
  });
  function C(i) {
    const h2 = F.get(i.type);
    if (!h2)
      return console.error("<Storyblok>", `No resolver found for node type ${i.type}`), "";
    const d = ce();
    if (i.type === "text") return h2(i, d);
    const p = i.content ? i.content.map(N) : void 0;
    return h2({
      ...i,
      children: p
    }, d);
  }
  function N(i) {
    return i.type === "doc" ? a ? i.content.map(C) : i.content.map(C).join("") : Array.isArray(i) ? i.map(C) : C(i);
  }
  return { render: N };
}
var z = false;
var G = [];
var Oe = (e) => new Promise((t, r) => {
  if (typeof window > "u") {
    r(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (n) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    z ? n() : G.push(n);
  }, document.getElementById("storyblok-javascript-bridge")) {
    t(void 0);
    return;
  }
  const s = document.createElement("script");
  s.async = true, s.src = e, s.id = "storyblok-javascript-bridge", s.onerror = (n) => r(n), s.onload = (n) => {
    G.forEach((o) => o()), z = true, t(n);
  }, document.getElementsByTagName("head")[0].appendChild(s);
});
var je = class extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
};
function xe(e, t, r) {
  if (!Number.isFinite(t)) throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(r)) throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let n = [], o = 0, l = false;
  const a = async () => {
    o++;
    const u = s.shift();
    if (u) try {
      const y = await e(...u.args);
      u.resolve(y);
    } catch (y) {
      u.reject(y);
    }
    const f = setTimeout(() => {
      o--, s.length > 0 && a(), n = n.filter((y) => y !== f);
    }, r);
    n.includes(f) || n.push(f);
  }, c = (...u) => l ? Promise.reject(new Error("Throttled function is already aborted and not accepting new promises")) : new Promise((f, y) => {
    s.push({
      resolve: f,
      reject: y,
      args: u
    }), o < t && a();
  });
  return c.abort = () => {
    l = true, n.forEach(clearTimeout), n = [], s.forEach((u) => u.reject(() => new je("Throttle function aborted"))), s.length = 0;
  }, c;
}
var Pe = xe;
var q = (e = "") => e.includes("/cdn/");
var Ne = (e, t = 25, r = 1) => ({
  ...e,
  per_page: t,
  page: r
});
var He = (e) => new Promise((t) => setTimeout(t, e));
var Ue = (e = 0, t) => Array.from({ length: e }, t);
var De = (e = 0, t = e) => {
  const r = Math.abs(t - e) || 0, s = e < t ? 1 : -1;
  return Ue(r, (n, o) => o * s + e);
};
var Be = async (e, t) => Promise.all(e.map(t));
var Me = (e = [], t) => e.map(t).reduce((r, s) => [...r, ...s], []);
var D = (e, t, r) => {
  const s = [];
  for (const n in e) {
    if (!Object.prototype.hasOwnProperty.call(e, n)) continue;
    const o = e[n];
    if (o == null) continue;
    const l = r ? "" : encodeURIComponent(n);
    let a;
    typeof o == "object" ? a = D(o, t ? t + encodeURIComponent(`[${l}]`) : l, Array.isArray(o)) : a = `${t ? t + encodeURIComponent(`[${l}]`) : l}=${encodeURIComponent(o)}`, s.push(a);
  }
  return s.join("&");
};
var J = (e) => {
  const t = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return t[e] ?? t.eu;
};
var Fe = class {
  constructor(e) {
    b(this, "baseURL"), b(this, "timeout"), b(this, "headers"), b(this, "responseInterceptor"), b(this, "fetch"), b(this, "ejectInterceptor"), b(this, "url"), b(this, "parameters"), b(this, "fetchOptions"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = false, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
  *
  * @param url string
  * @param params ISbStoriesParams
  * @returns Promise<ISbResponse | Error>
  */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], r = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((s) => {
      r.data = s;
    });
    for (const s of e.headers.entries()) t[s[0]] = s[1];
    return r.headers = { ...t }, r.status = e.status, r.statusText = e.statusText, r;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, r = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${D(this.parameters)}` : r = JSON.stringify(this.parameters);
    const s = new URL(t), n = new AbortController(), { signal: o } = n;
    let l;
    this.timeout && (l = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await this.fetch(`${s}`, {
        method: e,
        headers: this.headers,
        body: r,
        signal: o,
        ...this.fetchOptions
      });
      this.timeout && clearTimeout(l);
      const c = await this._responseHandler(a);
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);
    } catch (a) {
      return { message: a };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = true;
  }
  /**
  * Normalizes error messages from different response structures
  * @param data The response data that might contain error information
  * @returns A normalized error message string
  */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e)) return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error) return e.error;
      for (const t in e) {
        if (Array.isArray(e[t])) return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string") return `${t}: ${e[t]}`;
      }
      if (e.slug) return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((r, s) => {
      if (t.test(`${e.status}`)) return r(e);
      const n = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      s(n);
    });
  }
};
var Ve = Fe;
var K = "SB-Agent";
var U = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
};
var ze = {
  PUBLISHED: "published"
};
var j = {};
var A = {};
var Ge = class {
  /**
  *
  * @param config ISbConfig interface
  * @param pEndpoint string, optional
  */
  constructor(e, t) {
    b(this, "client"), b(this, "maxRetries"), b(this, "retriesDelay"), b(this, "throttle"), b(this, "accessToken"), b(this, "cache"), b(this, "resolveCounter"), b(this, "relations"), b(this, "links"), b(this, "version"), b(this, "richTextResolver"), b(this, "resolveNestedRelations"), b(this, "stringifiedStoriesCache"), b(this, "inlineAssets");
    let r = e.endpoint || t;
    if (!r) {
      const o = e.https === false ? "http" : "https";
      e.oauthToken ? r = `${o}://${J(e.region)}/v1` : r = `${o}://${J(e.region)}/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([o, l]) => {
      s.set(o, l);
    }), s.has(K) || (s.set(K, U.defaultAgentName), s.set(U.defaultAgentVersion, U.packageVersion));
    let n = 5;
    e.oauthToken && (s.set("Authorization", e.oauthToken), n = 3), e.rateLimit && (n = e.rateLimit), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttle = Pe(this.throttledRequest.bind(this), n, 1e3), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || true, this.stringifiedStoriesCache = {}, this.version = e.version || ze.PUBLISHED, this.inlineAssets = e.inlineAssets || false, this.client = new Ve({
      baseURL: r,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = A[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return q(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, r, s, n) {
    const o = this.factoryParamOptions(e, Ne(t, r, s));
    return this.cacheResponse(e, o, void 0, n);
  }
  get(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    q(s) && (t.version = t.version || this.version);
    const n = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, n, void 0, r);
  }
  async getAll(e, t = {}, r, s) {
    const n = (t == null ? void 0 : t.per_page) || 25, o = `/${e}`.replace(/\/$/, ""), l = r ?? o.substring(o.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const a = 1, c = await this.makeRequest(o, t, n, a, s), u = c.total ? Math.ceil(c.total / (c.perPage || n)) : 1, f = await Be(De(a, u), (y) => this.makeRequest(o, t, n, y + 1, s));
    return Me([c, ...f], (y) => Object.values(y.data[l]));
  }
  post(e, t = {}, r) {
    const s = `/${e}`;
    return this.throttle("post", s, t, r);
  }
  put(e, t = {}, r) {
    const s = `/${e}`;
    return this.throttle("put", s, t, r);
  }
  delete(e, t = {}, r) {
    t || (t = {});
    const s = `/${e}`;
    return this.throttle("delete", s, t, r);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, r) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, r);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, r) {
    const s = e[t];
    s && s.fieldtype === "multilink" && s.linktype === "story" && typeof s.id == "string" && this.links[r][s.id] ? s.story = this._cleanCopy(this.links[r][s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[r][s.uuid] && (s.story = this._cleanCopy(this.links[r][s.uuid]));
  }
  /**
  *
  * @param resolveId A counter number as a string
  * @param uuid The uuid of the story
  * @returns string | object
  */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
  * Resolves a field's value by replacing UUIDs with their corresponding story references
  * @param jtree - The JSON tree object containing the field to resolve
  * @param treeItem - The key of the field to resolve
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles both single string UUIDs and arrays of UUIDs:
  * - For single strings: directly replaces the UUID with the story reference
  * - For arrays: maps through each UUID and replaces with corresponding story references
  */
  _resolveField(e, t, r) {
    const s = e[t];
    typeof s == "string" ? e[t] = this.getStoryReference(r, s) : Array.isArray(s) && (e[t] = s.map((n) => this.getStoryReference(r, n)).filter(Boolean));
  }
  /**
  * Inserts relations into the JSON tree by resolving references
  * @param jtree - The JSON tree object to process
  * @param treeItem - The current field being processed
  * @param fields - The relation patterns to resolve (string or array of strings)
  * @param resolveId - The unique identifier for the current resolution context
  *
  * This method handles two types of relation patterns:
  * 1. Nested relations: matches fields that end with the current field name
  *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
  *
  * 2. Direct component relations: matches exact component.field patterns
  *    Example: "event.event_type" for component "event" and field "event_type"
  *
  * The method supports both string and array formats for the fields parameter,
  * allowing flexible specification of relation patterns.
  */
  _insertRelations(e, t, r, s) {
    if (Array.isArray(r) ? r.find((o) => o.endsWith(`.${t}`)) : r.endsWith(`.${t}`)) {
      this._resolveField(e, t, s);
      return;
    }
    const n = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(r) ? r.includes(n) : r === n) && this._resolveField(e, t, s);
  }
  /**
  * Recursively traverses and resolves relations in the story content tree
  * @param story - The story object containing the content to process
  * @param fields - The relation patterns to resolve
  * @param resolveId - The unique identifier for the current resolution context
  */
  iterateTree(e, t, r) {
    const s = (n, o = "") => {
      if (!(!n || n._stopResolving)) {
        if (Array.isArray(n)) n.forEach((l, a) => s(l, `${o}[${a}]`));
        else if (typeof n == "object") for (const l in n) {
          const a = o ? `${o}.${l}` : l;
          (n.component && n._uid || n.type === "link") && (this._insertRelations(n, l, t, r), this._insertLinks(n, l, r)), s(n[l], a);
        }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t, r) {
    let s = [];
    if (e.link_uuids) {
      const n = e.link_uuids.length, o = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        o.push(e.link_uuids.slice(a, c));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: o[a].join(",")
        })).data.stories.forEach((c) => {
          s.push(c);
        });
    } else s = e.links;
    s.forEach((n) => {
      this.links[r][n.uuid] = {
        ...n,
        _stopResolving: true
      };
    });
  }
  async resolveRelations(e, t, r) {
    let s = [];
    if (e.rel_uuids) {
      const n = e.rel_uuids.length, o = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        o.push(e.rel_uuids.slice(a, c));
      }
      for (let a = 0; a < o.length; a++)
        (await this.getStories({
          per_page: l,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: o[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((c) => {
          s.push(c);
        });
      s.length > 0 && (e.rels = s, delete e.rel_uuids);
    } else s = e.rels;
    s && s.length > 0 && s.forEach((n) => {
      this.relations[r][n.uuid] = {
        ...n,
        _stopResolving: true
      };
    });
  }
  /**
  *
  * @param responseData
  * @param params
  * @param resolveId
  * @description Resolves the relations and links of the stories
  * @returns Promise<void>
  *
  */
  async resolveStories(e, t, r) {
    var s, n;
    let o = [];
    if (this.links[r] = {}, this.relations[r] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (o = t.resolve_relations.split(",")), await this.resolveRelations(e, t, r)), t.resolve_links && [
      "1",
      "story",
      "url",
      "link"
    ].includes(t.resolve_links) && ((s = e.links) != null && s.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, r), this.resolveNestedRelations) for (const l in this.relations[r]) this.iterateTree(this.relations[r][l], o, r);
    e.story ? this.iterateTree(e.story, o, r) : e.stories.forEach((l) => {
      this.iterateTree(l, o, r);
    }), this.stringifiedStoriesCache = {}, delete this.links[r], delete this.relations[r];
  }
  async cacheResponse(e, t, r, s) {
    const n = D({
      url: e,
      params: t
    }), o = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const l = await o.get(n);
      if (l) return Promise.resolve(l);
    }
    return new Promise(async (l, a) => {
      var c;
      try {
        const u = await this.throttle("get", e, t, s);
        if (u.status !== 200) return a(u);
        let f = {
          data: u.data,
          headers: u.headers
        };
        if ((c = u.headers) != null && c["per-page"] && (f = Object.assign({}, f, {
          perPage: u.headers["per-page"] ? Number.parseInt(u.headers["per-page"]) : 0,
          total: u.headers["per-page"] ? Number.parseInt(u.headers.total) : 0
        })), f.data.story || f.data.stories) {
          const $ = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(f.data, t, `${$}`), f = await this.processInlineAssets(f);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await o.set(n, f);
        const y = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && f.data.cv && (y && A[t.token] && A[t.token] !== f.data.cv && await this.flushCache(), A[t.token] = f.data.cv), l(f);
      } catch (u) {
        if (u.response && u.status === 429 && (r = typeof r > "u" ? 0 : r + 1, r < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`), await He(this.retriesDelay), this.cacheResponse(e, t, r).then(l).catch(a);
        a(u);
      }
    });
  }
  throttledRequest(e, t, r, s) {
    return this.client.setFetchOptions(s), this.client[e](t, r);
  }
  cacheVersions() {
    return A;
  }
  cacheVersion() {
    return A[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (A[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (A[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(j[e]);
          },
          getAll() {
            return Promise.resolve(j);
          },
          set(e, t) {
            return j[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return j = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom) return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets) return e;
    const t = (r) => {
      if (!r || typeof r != "object") return r;
      if (Array.isArray(r)) return r.map((n) => t(n));
      let s = { ...r };
      s.fieldtype === "asset" && Array.isArray(e.data.assets) && (s = {
        ...s,
        ...e.data.assets.find((n) => n.id === s.id)
      });
      for (const n in s) typeof s[n] == "object" && (s[n] = t(s[n]));
      return s;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((r) => (r.content = t(r.content), r))), e;
  }
};
var qe = Ge;
var tt = (e = {}) => {
  const { apiOptions: t } = e;
  if (!t || !t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new qe(t) };
};
var Je = (e) => {
  if (typeof e != "object" || typeof e._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      e._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": `${t.id}-${t.uid}`
    } : {};
  } catch {
    return {};
  }
};
var Y = "https://app.storyblok.com/f/storyblok-v2-latest.js";
var Ke = (e, t, r = {}) => {
  var s;
  const n = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", o = new URL((s = window.location) == null ? void 0 : s.href).searchParams.get(
    "_storyblok"
  ), l = o !== null && +o === e;
  if (!(!n || !l)) {
    if (!e) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(r).on(["input", "published", "change"], (a) => {
        var c;
        a && (a.action === "input" && ((c = a.story) == null ? void 0 : c.id) === e ? t(a.story) : (a.action === "change" || a.action === "published") && a.storyId === e && window.location.reload());
      });
    });
  }
};
var Ye = (e = {}) => {
  var t, r;
  const {
    bridge: s,
    accessToken: n,
    use: o = [],
    apiOptions: l = {},
    bridgeUrl: a
  } = e;
  l.accessToken = l.accessToken || n;
  const c = { bridge: s, apiOptions: l };
  let u = {};
  o.forEach((y) => {
    u = { ...u, ...y(c) };
  }), a && (Y = a);
  const f = !(typeof window > "u") && ((r = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : r.includes("_storyblok_tk"));
  return s !== false && f && Oe(Y), u;
};
function rt(e, t) {
  return ee(t).render(e);
}
var te = defineComponent({
  __name: "StoryblokComponent",
  props: {
    blok: {}
  },
  setup(e, { expose: t }) {
    var a;
    const r = e, s = ref();
    t({
      value: s
    });
    const n = typeof resolveDynamicComponent(r.blok.component) != "string", o = inject("VueSDKOptions"), l = ref((a = r.blok.component) == null ? void 0 : a.replace(/_/g, "-"));
    return !n && o && (o.enableFallbackComponent ? (l.value = o.customFallbackComponent ?? "FallbackComponent", typeof resolveDynamicComponent(l.value) == "string" && console.error(
      `Is the Fallback component "${l.value}" registered properly?`
    )) : console.error(
      `Component could not be found for blok "${r.blok.component}"! Is it defined in main.ts as "app.component("${r.blok.component}", ${r.blok.component});"?`
    )), (c, u) => (openBlock(), createBlock(resolveDynamicComponent(l.value), mergeProps({
      ref_key: "blokRef",
      ref: s
    }, { ...c.$props, ...c.$attrs }), createSlots({ _: 2 }, [
      renderList(c.$slots, (f, y) => ({
        name: y,
        fn: withCtx(($) => [
          renderSlot(c.$slots, y, normalizeProps(guardReactiveProps($)))
        ])
      }))
    ]), 1040));
  }
});
var We = (e) => {
  var r;
  const t = (r = e == null ? void 0 : e.attrs) == null ? void 0 : r.body;
  return !Array.isArray(t) || t.length === 0 ? [] : t.map(
    (s) => {
      var n;
      return h(te, {
        blok: s,
        id: (n = e == null ? void 0 : e.attrs) == null ? void 0 : n.id
      }, e.children);
    }
  );
};
function Xe(e) {
  const t = {
    renderFn: h,
    // TODO: Check why this changed.
    // @ts-expect-error - createTextVNode types has been recently changed.
    textFn: createTextVNode,
    keyedResolvers: true,
    resolvers: {
      [k.COMPONENT]: We,
      ...e.resolvers
    }
  };
  return ee(t);
}
var Qe = defineComponent({
  __name: "StoryblokRichText",
  props: {
    doc: {},
    resolvers: {}
  },
  setup(e) {
    const t = e, r = ref(), s = () => r.value;
    return watch([() => t.doc, () => t.resolvers], ([n, o]) => {
      const { render: l } = Xe({
        resolvers: o ?? {}
      });
      r.value = l(n);
    }, {
      immediate: true,
      deep: true
    }), (n, o) => (openBlock(), createBlock(s));
  }
});
var Ze = {
  beforeMount(e, t) {
    if (t.value) {
      const r = Je(t.value);
      Object.keys(r).length > 0 && (e.setAttribute("data-blok-c", r["data-blok-c"]), e.setAttribute("data-blok-uid", r["data-blok-uid"]), e.classList.add("storyblok__outline"));
    }
  }
};
var re = (e) => {
  console.error(`You can't use ${e} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
var I = null;
var st = () => (I || re("useStoryblokApi"), I);
var nt = async (e, t = {}, r = {}) => {
  const s = ref(null);
  if (r.resolveRelations = r.resolveRelations ?? t.resolve_relations, r.resolveLinks = r.resolveLinks ?? t.resolve_links, onMounted(() => {
    s.value && s.value.id && Ke(
      s.value.id,
      (n) => s.value = n,
      r
    );
  }), I) {
    const { data: n } = await I.get(
      `cdn/stories/${e}`,
      t
    );
    s.value = n.story;
  } else
    re("useStoryblok");
  return s;
};
var ot = {
  install(e, t = {}) {
    e.directive("editable", Ze), e.component("StoryblokComponent", te), e.component("StoryblokRichText", Qe), t.enableFallbackComponent && !t.customFallbackComponent && e.component(
      "FallbackComponent",
      defineAsyncComponent(() => import("./FallbackComponent-vpkAikkq-QL5BYUVM.js"))
    );
    const { storyblokApi: r } = Ye(t);
    I = r || null, e.provide("VueSDKOptions", t);
  }
};
export {
  k as BlockTypes,
  T as MarkTypes,
  te as StoryblokComponent,
  Qe as StoryblokRichText,
  ot as StoryblokVue,
  Ae as TextTypes,
  tt as apiPlugin,
  rt as renderRichText,
  ee as richTextResolver,
  nt as useStoryblok,
  st as useStoryblokApi,
  Ke as useStoryblokBridge,
  Xe as useStoryblokRichText
};
//# sourceMappingURL=@storyblok_vue.js.map
